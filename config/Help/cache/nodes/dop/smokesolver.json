{"type": "root", "attrs": {"type": "node", "context": "dop", "internal": "smokesolver::2.0", "icon": "DOP/smokesolver", "tags": "pyro", "version": "2.0", "since": "12.0", "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Smoke Solver"], "extent": [117, 134]}, {"type": "summary", "indent": 0, "text": ["Sets and configures a Smoke solver. This is a slightly lower-level solver that is the basis for the Pyro solver."], "extent": [134, 255]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/pyro/pyro_look", "type": "link", "text": ["Pyro look development"], "fullpath": "/pyro/pyro_look.html"}, " for information on using the parameters to achieve different flame and smoke looks."], "extent": [255, 384]}, {"type": "para", "indent": 0, "text": ["The smoke solver provides the basics of smoke simulation, whereas the ", {"scheme": "Node", "value": "/nodes/dop/pyrosolver", "type": "link", "text": ["Pyro Solver"], "fullpath": "/nodes/dop/pyrosolver.html"}, " adds flame simulation and extra shaping controls. If you just want to generate smoke, the smoke solver is useful since it is simpler and expert users can build their own extensions on it. However, the ", {"scheme": "Node", "value": "/nodes/dop/pyrosolver", "type": "link", "text": ["Pyro Solver"], "fullpath": "/nodes/dop/pyrosolver.html"}, " is more flexible."], "extent": [384, 742]}, {"type": "para", "indent": 0, "text": ["See ", {"scheme": null, "value": "/pyro/pyro", "type": "link", "text": ["how to use the Pyro tools"], "fullpath": "/pyro/pyro.html"}, " for information on creating simulations using the shelf tools."], "extent": [742, 849]}, {"level": 2, "id": "setup", "container": true, "type": "h", "indent": 0, "text": ["Setting up"], "extent": [849, 874], "body": [{"type": "para", "indent": 0, "text": ["If you ", {"scheme": null, "value": "/pyro/pyro", "type": "link", "text": ["use the shelf tools"], "fullpath": "/pyro/pyro.html"}, " to create Pyro effects, they will set up the sourcing, solver, and output object for you automatically."], "extent": [874, 1020]}, {"type": "para", "indent": 0, "text": ["If you are setting up a pyro network from scratch, you can use the ", {"scheme": "Node", "value": "/nodes/dop/smokeobject", "type": "link", "text": ["Smoke Object node"], "fullpath": "/nodes/dop/smokeobject.html"}, " to create a DOP object with the data required by the Pyro solver already attached. If you already have a DOP object, you can use the ", {"scheme": "Node", "value": "/nodes/dop/smokeconfigureobject", "type": "link", "text": ["Smoke Configure Object node"], "fullpath": "/nodes/dop/smokeconfigureobject.html"}, " to add the necessary data to it."], "extent": [1020, 1355]}, {"type": "para", "indent": 0, "text": ["This solver makes use of various field subdata on the object."], "extent": [1355, 1418]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["The object should have a scalar field ", {"type": "code", "text": ["density"]}, " for the density of the smoke."], "extent": [1418, 1499]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The object should have a vector field ", {"type": "code", "text": ["vel"]}, " for the velocity at each voxel."], "extent": [1499, 1578]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Optionally, the object can have a scalar field ", {"type": "code", "text": ["temperature"]}, " for internal buoyancy calculations."], "extent": [1578, 1678]}], "container": true}]}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [1678, 1686], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["Object"], "extent": [1686, 1695], "body": [{"type": "para", "indent": 4, "text": ["A ", {"scheme": "Node", "value": "/nodes/dop/smokeobject", "type": "link", "text": ["Smoke object"], "fullpath": "/nodes/dop/smokeobject.html"}, " to work on. Note that a smoke\n    object can contain multiple containers."], "extent": [1722, 1839]}], "container": true, "attrs": {"id": "object_input"}}, {"type": "dt", "indent": 0, "text": ["Pre-solve"], "extent": [1839, 1850], "body": [{"type": "para", "indent": 4, "text": ["Run the network branch attached to this input before each solving\n    step. In the standard ", {"scheme": null, "value": "/pyro/pyro", "type": "link", "text": ["pyro setup"], "fullpath": "/pyro/pyro.html"}, ", the attached node (", {"scheme": "Node", "value": "/nodes/dop/gasresizefluiddynamic", "type": "link", "text": ["Gas Resize Fluid Dynamic"], "fullpath": "/nodes/dop/gasresizefluiddynamic.html"}, ") automatically resizes the fluid containers at each step."], "extent": [1879, 2136]}], "container": true, "attrs": {"id": "presolve_input"}}, {"type": "dt", "indent": 0, "text": ["Velocity update"], "extent": [2136, 2153], "body": [{"type": "para", "indent": 4, "text": ["Nodes attached to this input can edit the simulation network\u2019s velocity fields, for example to apply custom forces, ", {"type": "em", "text": ["before"]}, " the ", {"type": "q", "text": ["project gas non-divergent"]}, " step (see also the ", {"type": "q", "text": ["Sourcing (post-solve)"]}, " input below)."], "extent": [2183, 2402]}], "container": true, "attrs": {"id": "velupdate_input"}}, {"type": "dt", "indent": 0, "text": ["Advection"], "extent": [2402, 2413], "body": [{"type": "para", "indent": 4, "text": ["Connect a ", {"scheme": "Node", "value": "/nodes/dop/gasadvect", "type": "link", "text": ["Gas Advect node"], "fullpath": "/nodes/dop/gasadvect.html"}, " to this input to allow the it to advect the points of geometry data attached to the container based on the fields in this solver."], "extent": [2443, 2630]}], "container": true, "attrs": {"id": "advection_input"}}, {"type": "dt", "indent": 0, "text": ["Sourcing (post-solve)"], "extent": [2630, 2653], "body": [{"type": "para", "indent": 4, "text": ["The main use for this input is to add volumes attached to this input as fuel sources, density sources, sinks, collision fields, pumps, etc. This will usually be done by a ", {"scheme": "Node", "value": "/nodes/dop/volumesource", "type": "link", "text": ["Volume Source node"], "fullpath": "/nodes/dop/volumesource.html"}, " that imports volumes from a geometry network. See ", {"scheme": null, "value": "/dyno/fluid_sourcing", "type": "link", "text": ["pyro sourcing"], "fullpath": "/dyno/fluid_sourcing.html"}, " for more information."], "extent": [2682, 3014]}, {"type": "para", "indent": 4, "text": ["Nodes attached to this input can also edit the simulation network\u2019s velocity fields, for example to apply custom forces, ", {"type": "em", "text": ["after"]}, " the ", {"type": "q", "text": ["project gas non-divergent"]}, " step."], "extent": [3014, 3186]}], "container": true, "attrs": {"id": "sourcing_input"}}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [3186, 3198], "body": [{"level": 2, "id": "simtab", "container": true, "type": "h", "indent": 0, "text": ["Simulation"], "extent": [3198, 3225], "body": [{"type": "para", "indent": 0, "text": ["These parameters control how the simulation develops over time. See ", {"scheme": null, "value": "/pyro/pyro", "type": "link", "text": ["how pyro simulations work"], "fullpath": "/pyro/pyro.html"}, " for information on how the temperature and velocity fields drive the simulation to a great extent."], "extent": [3225, 3433]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Time Scale"], "extent": [3433, 3445], "body": [{"type": "para", "indent": 4, "text": ["A scaling factor for time inside this solver. ", {"type": "code", "text": ["1"]}, " is normal speed, greater than ", {"type": "code", "text": ["1"]}, " makes the pyro sim appear sped up, less than ", {"type": "code", "text": ["1"]}, " makes the pyro sim appear to be in slow motion."], "extent": [3465, 3651]}, {"type": "para", "indent": 4, "text": ["You can use expression functions such as ", {"scheme": "Exp", "value": "/expressions/doptime", "type": "link", "text": "", "fallback_text": "doptime()", "fullpath": "/expressions/doptime.html"}, ", ", {"scheme": "Exp", "value": "/expressions/dopframe", "type": "link", "text": "", "fallback_text": "dopframe()", "fullpath": "/expressions/dopframe.html"}, ",", {"scheme": "Exp", "value": "/expressions/dopsttot", "type": "link", "text": "", "fallback_text": "dopsttot()", "fullpath": "/expressions/dopsttot.html"}, ", and ", {"scheme": "Exp", "value": "/expressions/dopttost", "type": "link", "text": "", "fallback_text": "dopttost()", "fullpath": "/expressions/dopttost.html"}, " to convert between global times and simulation times."], "extent": [3651, 3816]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [3816, 3826], "body": [{"type": "para", "indent": 8, "text": ["Changing the ", {"type": "ui", "text": ["Time Scale"]}, " only affects the timestep of the simulation. If adding velocities calculated in SOPs to the simulation for collisions or pumps with the ", {"scheme": "Node", "value": "/nodes/dop/volumesource", "type": "link", "text": ["Volume Source DOP "], "fullpath": "/nodes/dop/volumesource.html"}, ", scale the incoming velocities by ", {"type": "code", "text": ["1 / timescale"]}, " to match the timestep of the simulation."], "extent": [3826, 4141]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "timescale"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Temperature Diffusion"], "extent": [4141, 4164], "body": [{"type": "para", "indent": 4, "text": ["A Gaussian blur factor on the temperature field. Higher values spread the temperature out more and create a less sharply defined effect and more cooling. For example, a value of ", {"type": "code", "text": ["2 "]}, "will blur the temperature field by a radius of 2 every second."], "extent": [4164, 4418]}, {"type": "para", "indent": 4, "text": ["(The real-world motivation for this parameter is to simulate turbulence at a finer scale than the sim\u2019s resolution, which spreads the field out.)"], "extent": [4418, 4569]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Cooling Rate"], "extent": [4569, 4583], "body": [{"type": "para", "indent": 4, "text": ["How fast the temperature field cools to zero. A value of 0.9 will decrease\n    the temperature of hot gas by 90% (to 10% of its original value) every\n    second."], "extent": [4583, 4754]}, {"type": "warning_group", "body": [{"type": "warning", "indent": 4, "role": "item", "extent": [4754, 4767], "body": [{"type": "para", "indent": 8, "text": ["This is the inverse of the ", {"type": "ui", "text": ["Cooling Rate"]}, " parameter in Houdini 11 and lower versions."], "extent": [4767, 4864]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Viscosity"], "extent": [4864, 4875], "body": [{"type": "para", "indent": 4, "text": ["The ", {"type": "q", "text": ["fluid-ness"]}, " of the velocity field. Higher values make neighboring voxels have the same velocity, creating a more flowing look. A value of ", {"type": "code", "text": ["0"]}, " allows adjacent voxels to move any direction without resistance, creating a more chaotic, turbulent look."], "extent": [4875, 5137]}, {"type": "para", "indent": 4, "text": ["(Inside the solver, higher viscosity values introduce a penalty when a voxel\u2019s velocity varies from that of its neighbors. This is currently implemented by applying a diffusive term to the velocity field.)"], "extent": [5137, 5348]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Buoyancy Lift"], "extent": [5348, 5363], "body": [{"type": "para", "indent": 4, "text": ["An upward force at each voxel scaled by the difference between the ambient temperature and voxel\u2019s temperature, so hotter areas will get more lift and cooler areas will sink. Increasing this makes the effect rise faster and go higher."], "extent": [5363, 5603]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Buoyancy Dir"], "extent": [5603, 5617], "body": [{"type": "para", "indent": 4, "text": ["The direction in which buoyancy is applied.  This is usually the Up direction of your simulation, but often can be altered to quickly tweak the look of a sim."], "extent": [5617, 5781]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "colortab", "container": true, "type": "h", "indent": 0, "text": ["Color"], "extent": [5781, 5804], "body": [{"type": "para", "indent": 0, "text": ["The solver is capable of managing the smoke object\u2019s color data. To this end, it takes care of two\nfields: ", {"type": "code", "text": ["Cd"]}, ", which stores the color value that can be used as the ", {"type": "ui", "text": ["Diffuse Field"]}, " for visualization,\nand ", {"type": "code", "text": ["Alpha"]}, ", which contains the amount of color at each point in space. The ", {"type": "code", "text": ["Alpha"]}, " field is important\nfor determining how colors should be mixed. For example, if white and black smoke mix, the resultant\ngray will be lighter if the white component has a higher ", {"type": "code", "text": ["Alpha"]}, " value. The clip below provides a\nvisual comparison: yellow smoke in the right clip is sourced with a larger value of ", {"type": "code", "text": ["Alpha"]}, "."], "extent": [5804, 6404]}, {"type": "video_group", "body": [{"ext": null, "type": "video", "indent": 0, "role": "item", "extent": [6404, 6412], "body": [], "container": true, "attrs": {"src": "/videos/smoke_color_alpha.mp4"}}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Dissipation"], "extent": [6453, 6466], "body": [{"type": "para", "indent": 4, "text": ["Causes the amount of color (", {"type": "code", "text": ["Alpha"]}, " field) to reduce over time. Note that this does not directly\n    affect smoke\u2019s color, but makes it easier to mix in new color via sourcing."], "extent": [6511, 6693]}], "container": true, "attrs": {"id": "enable_color_dissipation color_evap"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Blur"], "extent": [6693, 6699], "body": [{"type": "para", "indent": 4, "text": ["Blurs the smoke\u2019s color field by mixing its values in neighborhoods of the given size."], "extent": [6737, 6829]}], "container": true, "attrs": {"id": "enable_color_blur color_blur"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Sharpening"], "extent": [6829, 6841], "body": [{"type": "para", "indent": 4, "text": ["Sharpens the smoke\u2019s color field, effectively discouraging mixing of different colors."], "extent": [6891, 6983]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [6983, 6993], "body": [{"type": "para", "indent": 8, "text": ["Large values of the sharpening parameter may introduce visible artifacts. In some cases,\n        the added noise may be reduced by increasing the sharpening ", {"type": "ui", "text": ["Threshold"]}, "."], "extent": [6993, 7174]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "enable_color_sharpening color_sharpening"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": "colordissipationtab", "container": true, "type": "h", "indent": 0, "text": ["Dissipation"], "extent": [7174, 7216], "body": [{"type": "para", "indent": 0, "text": ["When dissipation is turned on, the amount of color in the smoke reduces over time, making it easier to\nsource new color."], "extent": [7216, 7339]}, {"type": "video_group", "body": [{"ext": null, "type": "video", "indent": 0, "role": "item", "extent": [7339, 7347], "body": [], "container": true, "attrs": {"src": "/videos/smoke_color_dissipate.mp4"}}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Control Field"], "extent": [7392, 7407], "body": [{"type": "para", "indent": 4, "text": ["When turned on, the amount of dissipation is scaled by the content of this field."], "extent": [7468, 7555]}], "container": true, "attrs": {"id": "use_color_dissipation_field color_dissipation_field"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Control Range"], "extent": [7555, 7570], "body": [{"type": "para", "indent": 4, "text": ["Map from this range of values in the control field."], "extent": [7611, 7668]}], "container": true, "attrs": {"id": "color_dissipation_control_range"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Remap Dissipation Field"], "extent": [7668, 7693], "body": [{"type": "para", "indent": 4, "text": ["The ramp\u2019s vertical axis is amount of dissipation, and the horizontal axis spans ", {"type": "ui", "text": ["Control Range"]}, ".\n    The default ramp, for example, reduces the amount of color faster in areas where temperature is low."], "extent": [7726, 7936]}], "container": true, "attrs": {"id": "color_remap_dissipation"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "colorblurtab", "container": true, "type": "h", "indent": 0, "text": ["Blur"], "extent": [7936, 7964], "body": [{"type": "para", "indent": 0, "text": ["Blur encourages mixing of smoke colors."], "extent": [7964, 8006]}, {"type": "video_group", "body": [{"ext": null, "type": "video", "indent": 0, "role": "item", "extent": [8006, 8014], "body": [], "container": true, "attrs": {"src": "/videos/smoke_color_blur.mp4"}}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Radius"], "extent": [8054, 8062], "body": [{"type": "para", "indent": 4, "text": ["Controls how far out the colors will blur per second."], "extent": [8089, 8148]}], "container": true, "attrs": {"id": "color_blur_radius"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Filter"], "extent": [8148, 8156], "body": [{"type": "para", "indent": 4, "text": ["Shape of the blur kernel."], "extent": [8183, 8214]}], "container": true, "attrs": {"id": "color_blur_radius"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "colorsharpnesstab", "container": true, "type": "h", "indent": 0, "text": ["Sharpness"], "extent": [8214, 8252], "body": [{"type": "para", "indent": 0, "text": ["Sharpening fights mixing, helping preserve sharp boundaries between colors."], "extent": [8252, 8330]}, {"type": "video_group", "body": [{"ext": null, "type": "video", "indent": 0, "role": "item", "extent": [8330, 8338], "body": [], "container": true, "attrs": {"src": "/videos/smoke_color_sharpen.mp4"}}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Radius"], "extent": [8381, 8389], "body": [{"type": "para", "indent": 4, "text": ["Sharpening boosts the deviation of colors from averaged (blurred) values. This parameter controls\n    the distance to which blurring is performed."], "extent": [8419, 8571]}], "container": true, "attrs": {"id": "color_sharpen_radius"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Threshold"], "extent": [8571, 8582], "body": [{"type": "para", "indent": 4, "text": ["Sharpening boosts the deviation of colors from averaged (blurred) values. If the deviation falls\n    below this threshold at a voxel, no sharpening is done to it. Increasing this value can help reduce\n    the amount of introduced sharpening noise."], "extent": [8615, 8868]}], "container": true, "attrs": {"id": "color_sharpen_threshold"}, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": "relationships", "container": true, "type": "h", "indent": 0, "text": ["Relationships"], "extent": [8868, 8904], "body": [{"type": "para", "indent": 0, "text": ["Prior to Houdini 12, the Pyro solver used DOP relationships to associate sources, pumps, sinks, and collision geometry with a fluid container, using the ", {"scheme": "Node", "value": "/nodes/dop/merge", "type": "link", "text": ["Merge DOP"], "fullpath": "/nodes/dop/merge.html"}, " and/or ", {"scheme": "Node", "value": "/nodes/dop/applyrel", "type": "link", "text": ["Apply relationship DOP"], "fullpath": "/nodes/dop/applyrel.html"}, " to create the relationship. The preferred method in Houdini 12 and later is to ", {"scheme": null, "value": "/dyno/fluid_sourcing", "type": "link", "text": ["use SOP networks to create sources, pumps, sinks, and collision geometry"], "fullpath": "/dyno/fluid_sourcing.html"}, " and import them using the ", {"scheme": "Node", "value": "/nodes/dop/sourcevolume", "type": "link", "text": ["Source volume DOP"], "fullpath": "/nodes/dop/sourcevolume.html"}, "."], "extent": [16, 491]}, {"type": "para", "indent": 0, "text": ["If you want to use the old relationship method to set up sources, sinks, etc., you can enable relationships using the parameters on this tab. By default, relationships are turned off, and the solver ignores relationship data."], "extent": [491, 718]}, {"type": "para", "indent": 0, "text": ["You can use both methods (import SOP geometry and attach it to the solver\u2019s ", {"type": "q", "text": ["sourcing"]}, " input, as well as set up DOP object relationships). When relationships are enabled, the solver will combine the sources, sinks, etc. from both methods."], "extent": [718, 958]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Relationships"], "extent": [958, 980], "body": [{"type": "para", "indent": 4, "text": ["Use object relationship data to add sources, pumps, sinks, and collision geometry to the simulation (in addition to imported data connected to the sourcing input, if any)."], "extent": [980, 1156]}], "container": true, "role": "item"}], "container": true}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Sources"], "extent": [8934, 8950], "body": [{"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [8950, 8956], "body": [{"type": "para", "indent": 8, "text": ["When using a source relationship, make sure the source object is emitting temperature. You can set this up on the object\u2019s physical properties tab."], "extent": [8956, 9113]}], "container": true}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Source Relationship"], "extent": [9113, 9141], "body": [{"type": "para", "indent": 8, "text": ["Use DOP objects with a ", {"type": "q", "text": ["source"]}, " relationship to the solver."], "extent": [9141, 9218]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Add Source To"], "extent": [9218, 9233], "body": [{"type": "para", "indent": 8, "text": ["The field to add the source to. The default is ", {"type": "code", "text": ["density"]}, ", which will create smoke. To create flame, you could change this to ", {"type": "code", "text": ["fuel"]}, " and set the temperature physical property of the source object."], "extent": [9233, 9446]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Source Merge"], "extent": [9446, 9460], "body": [{"type": "para", "indent": 8, "text": ["How the source object\u2019s volume will be added to the simulation.\n        Scale controls the addition amount."], "extent": [9460, 9585]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Merge"], "extent": [9585, 9601], "body": [{"type": "para", "indent": 4, "text": ["How the source object\u2019s velocity will affect the\n    container\u2019s velocity field. Scale controls the amount to add.   "], "extent": [9601, 9724]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Temperature Merge"], "extent": [9724, 9743], "body": [{"type": "para", "indent": 4, "text": ["How the source object\u2019s temperature physical\n    parameter will affect the container\u2019s temperature field. Scale controls the amount of temperature to add."], "extent": [9743, 9907]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Type"], "extent": [9907, 9922], "body": [{"type": "para", "indent": 4, "text": ["How to measure velocity on the source object. If the source geometry does not deform (change shape) over time, use ", {"type": "q", "text": ["Rigid velocity"]}, ". If the source deforms but does not change topology over time, use ", {"type": "q", "text": ["Point velocity"]}, "."], "extent": [9944, 10166]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Rigid Velocity"], "extent": [10166, 10186], "body": [{"type": "para", "indent": 8, "text": ["Treat the source object as non-deforming."], "extent": [10186, 10245]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Point Velocity"], "extent": [10245, 10265], "body": [{"type": "para", "indent": 8, "text": ["Use point history to allow deforming geometry. This only\n        works if the topology of the source geometry doesn\u2019t change."], "extent": [10265, 10408]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Volume Velocity"], "extent": [10408, 10429], "body": [{"type": "para", "indent": 8, "text": ["Use the SDF representation of the object. Allows deforming geometry and does not require a fixed topology over time, but cannot detect tangential velocities."], "extent": [10429, 10596]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "veltype"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Pumps"], "extent": [10596, 10610], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Pump Relationship"], "extent": [10610, 10637], "body": [{"type": "para", "indent": 8, "text": ["Use DOP objects with a ", {"type": "q", "text": ["pump"]}, " relationship to the solver."], "extent": [10637, 10712]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Merge"], "extent": [10712, 10728], "body": [{"type": "para", "indent": 4, "text": ["How the source object\u2019s velocity will affect the\n    container\u2019s velocity field. Scale controls the amount of velocity to add."], "extent": [10728, 10860]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Velocity Type"], "extent": [10860, 10875], "body": [], "container": true, "attrs": {"id": "pumpveltype", "contentfromt": "#veltype"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Temperature Merge"], "extent": [10925, 10944], "body": [{"type": "para", "indent": 4, "text": ["Whether the object\u2019s temperature property affects the temperature field of the container. If you choose ", {"type": "q", "text": ["Set interior"]}, ", the part of the temperature field corresponding to the inside the object will be set to the object\u2019s temperature."], "extent": [10979, 11218]}], "container": true, "attrs": {"id": "pumptemperaturemerge"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [11218, 11237], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Collide Relationship"], "extent": [11237, 11267], "body": [{"type": "para", "indent": 8, "text": ["Use DOP objects with a ", {"type": "q", "text": ["collision"]}, " relationship to the solver."], "extent": [11267, 11339]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Temperature Merge"], "extent": [11339, 11358], "body": [{"type": "para", "indent": 4, "text": ["Whether the object\u2019s temperature property affects the temperature field of the container. If you choose ", {"type": "q", "text": ["Collision interior"]}, ", the part of the temperature field corresponding to the inside the object will be set to the object\u2019s temperature."], "extent": [11398, 11643]}], "container": true, "attrs": {"id": "collisiontemperaturemerge"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Restrict Mask to Bandwidth"], "extent": [11643, 11671], "body": [{"type": "para", "indent": 4, "text": ["Normally the collision mask SDF is only calculated up to a certain distance from the original collision geometry. Turn this off to compute the full range of the mask if you need it for some special effect, such as having things react before they reach the object."], "extent": [11671, 11944]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Point Velocity for Collisions"], "extent": [11944, 11979], "body": [{"type": "para", "indent": 4, "text": ["Turn this on if the collision geometry is deforming (changing shape) over time, but has consistent topology (e.g. number of points). If the topology changes over time, turn on ", {"type": "ui", "text": ["Use volume velocity for collisions"]}, "."], "extent": [11979, 12200]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Use Volume Velocity for Collisions"], "extent": [12200, 12236], "body": [{"type": "para", "indent": 4, "text": ["Turn this on if the collision geometry is deforming (changing shape) and topology (e.g. number of points) over time."], "extent": [12236, 12358]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Collide with Non-SDF"], "extent": [12358, 12380], "body": [{"type": "para", "indent": 4, "text": ["Allows the fluid to collide with objects that don\u2019t have\n    Geometry/SDF, such as other fluids."], "extent": [12380, 12482]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Extrapolate into Collisions"], "extent": [12482, 12511], "body": [{"type": "para", "indent": 4, "text": ["Copies the density and fuel fields into the collision field. This causes the smoke to become ", {"type": "q", "text": ["sticky"]}, " to avoid an air gap between the smoke and the collision field. This also prevents smoke from passing through moving collision fields."], "extent": [12511, 12752]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Sink"], "extent": [12752, 12765], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Sink Relationship"], "extent": [12765, 12792], "body": [{"type": "para", "indent": 4, "text": ["Use DOP objects with a ", {"type": "q", "text": ["sink"]}, " relationship to the solver."], "extent": [12792, 12855]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Advanced"], "extent": [12855, 12870], "body": [{"type": "para", "indent": 0, "text": ["Generally, you should not need to change these parameters."], "extent": [12870, 12931]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Use OpenCL"], "extent": [12931, 12943], "body": [{"type": "para", "indent": 4, "text": ["Enable GPU acceleration on certain microsolvers. This may not work on all graphics cards or operating systems. Check the System Requirements information in the Support section of the Side Effects Software website."], "extent": [12960, 13179]}, {"type": "para", "indent": 4, "text": ["You should have a fairly recent graphics card and fully updated drivers. Start with a low resolution test simulation (for example, a 64", {"tag": "sup", "attrs": {}, "type": "xml", "text": ["3"]}, " grid) to verify that it runs with OpenCL, then try increasing the resolution. The additional memory-transfer overhead of using OpenCL will only become worth it at high resolutions, around 256", {"tag": "sup", "attrs": {}, "type": "xml", "text": ["3"]}, "."], "extent": [13179, 13537]}, {"type": "para", "indent": 4, "text": ["With the plain smoke solver, simulation after the first frame sourcing will use the GPU. If you add a microsolver that isn\u2019t GPU-enabled, Houdini does the GPU required CPU copying instead of raising an error."], "extent": [13537, 13751]}, {"type": "para", "indent": 4, "text": ["For fastest speeds, the system needs to minimize copying to and from the video card. The example file demonstrates several methods for minimizing copying. See the ", {"scheme": null, "value": "/examples/nodes/dop/smokeobject/OpenCL", "type": "link", "text": ["OpenCL smoke example file"], "fullpath": "/examples/nodes/dop/smokeobject/OpenCL.html"}, " for an explanation of how to set up a fast simulation using GPU acceleration."], "extent": [13751, 14064]}, {"type": "para", "indent": 4, "text": ["A very high-resolution plain smoke solver simulation should be faster with OpenCL. However, default Pyro effects will not automatically simulate faster."], "extent": [14064, 14222]}, {"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["They tend to be very low resolution for fast initial playback, so they don\u2019t have enough voxels for the GPU acceleration to greatly exceed the overhead."], "extent": [14222, 14382]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["They have a lot of non-GPU shaping nodes. While many nodes are GPU-enabled (such as vortex confinement), quite a few Pyro nodes are based on VOPs and are not GPU-enabled."], "extent": [14382, 14560]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Caching is enabled by default in DOPs."], "extent": [14560, 14610]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Resizing is enabled by default. Resizing has to go through the CPU to manage the field changes. It can also fragment the GPU memory resulting in out-of-memory errors."], "extent": [14610, 14784]}], "container": true}], "container": true, "attrs": {"id": "opencl"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Min Substeps"], "extent": [14784, 14798], "body": [{"type": "para", "indent": 4, "text": ["Forces the solver to run a minimum number of substeps. Normally the pyro solver works best with no substeps. If you have smoke and unusual forces, you may want to increase this parameter for better stability. Increasing this parameter will usually make the simulation much slower."], "extent": [14828, 15114]}], "container": true, "attrs": {"id": "minimumsubsteps"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Max Substeps"], "extent": [15114, 15128], "body": [{"type": "para", "indent": 4, "text": ["Forces the solver to not run more substeps than this maximum. Normally the pyro solver works best with no substeps. If you have smoke and unusual forces, you may want to increase this parameter for better stability. Increasing this parameter will usually make the simulation much slower."], "extent": [15151, 15444]}], "container": true, "attrs": {"id": "substeps"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["CFL Condition"], "extent": [15444, 15459], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Max Substeps"]}, " is greater than ", {"type": "code", "text": ["1"]}, ", the solver uses this parameter to decide the number of substeps. The ", {"type": "q", "text": ["condition"]}, " is that no substep can allow objects to interpenetrate by more than this many voxels. Higher values allow a substep to move smoke by more voxels, possibly letting it pass through collision objects."], "extent": [15481, 15808]}], "container": true, "attrs": {"id": "cflcond"}, "role": "item"}, {"type": "parameters_item", "indent": 4, "text": ["Quantize to Max Substeps"], "extent": [3625, 3655], "body": [{"type": "para", "indent": 12, "text": ["When turned on, use substeps that divide up the frame by ", {"type": "ui", "text": ["Max Substeps"]}, " so that the time always lands on a multiple of 1/", {"type": "ui", "text": ["Max Substeps"]}, ". "], "extent": [3682, 3837]}, {"type": "para", "indent": 12, "text": ["For example, if ", {"type": "ui", "text": ["Max Substeps"]}, " is set to 4, but the ", {"type": "ui", "text": ["CFL Condition"]}, " only requires 3 substeps, the solver will divide up the frame into 3 substeps, with the substeps located at multiples of 1/", {"type": "ui", "text": ["Max Substeps"]}, ". One combination of the substep lengths could be 0.25, 0.5, and 0.25, with the frame divided up from 0-0.25, 0.25-0.75, and 0.75-1. The solver also takes into account the current state of the particles (particle size and velocity) when dividing the frame into substeps."], "extent": [3837, 4332]}, {"type": "para", "indent": 12, "text": ["This option can be useful for re-using input geometry that has been cached to file at increments of 1/", {"type": "ui", "text": ["Max Substeps"]}, ". For example, if your geometry is cached on disk at 4 substeps per frame, then you may want your simulation\u2019s substeps to always land on a multiple of 0.25 so that you don\u2019t have to interpolate the geometry. "], "extent": [4332, 4673]}], "container": true, "attrs": {"id": "quantize"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Frames Before Solve"], "extent": [15850, 15871], "body": [{"type": "para", "indent": 4, "text": ["Delays the actual simulation this many frames after object creation.\n    Sourcing will still occur in these frames.  This may be needed if\n    some solve nodes cannot be processed before certain initial conditions\n    have been met."], "extent": [15905, 16143]}], "container": true, "attrs": {"id": "frames_before_solve"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 3, "id": "adv_externaltab", "container": true, "type": "h", "indent": 0, "text": ["External Forces"], "extent": [16143, 16185], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Scaled Forces"], "extent": [16185, 16201], "body": [{"type": "para", "indent": 4, "text": ["A list of forces to scale by the value of the ", {"type": "code", "text": ["forcescale"]}, " field at each voxel. The default is all forces except gravity."], "extent": [16201, 16328]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Absolute Forces"], "extent": [16328, 16345], "body": [{"type": "para", "indent": 4, "text": ["A list of forces to apply uniformly to all voxels, ignoring the ", {"type": "code", "text": ["forcescale"]}, " field."], "extent": [16345, 16434]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "adv_restfieldtab", "container": true, "type": "h", "indent": 0, "text": ["Rest Field"], "extent": [16434, 16472], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Enable Rest"], "extent": [16472, 16486], "body": [{"type": "para", "indent": 4, "text": ["Creates rest fields, which can be used to track the position of the fluid over time. Turn this on to correctly map noise or textures in the volume shader."], "extent": [16486, 16646]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Dual Rest Fields"], "extent": [16646, 16664], "body": [{"type": "para", "indent": 4, "text": ["Creates a ", {"type": "code", "text": ["rest2"]}, " field that is one back from the main ", {"type": "code", "text": ["rest"]}, " field, allowing you to run long simulations without popping."], "extent": [16664, 16796]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Frames Between Solve"], "extent": [16796, 16818], "body": [{"type": "para", "indent": 4, "text": ["Number of frames before resetting the rest field."], "extent": [16818, 16873]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Frame Offset"], "extent": [16873, 16887], "body": [{"type": "para", "indent": 4, "text": ["Which frame the rest field will be reset on. If you are prerolling the simulation, delaying the rest field initialization until after the preroll will usually give a better result."], "extent": [16887, 17077]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Time Scale"], "extent": [17077, 17089], "body": [{"type": "para", "indent": 4, "text": ["How fast the rest field moves in response to the velocity field. A value of ", {"type": "code", "text": ["1"]}, " would make the rest field match the fluid exactly, however that would quickly smear the rest field out in streaks. Values lower than ", {"type": "code", "text": ["1"]}, " move the rest field slower than the actual fluid, decreasing streaking."], "extent": [17113, 17407]}], "container": true, "attrs": {"id": "timescale"}, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "adv_projectiontab", "container": true, "type": "h", "indent": 0, "text": ["Projection"], "extent": [17407, 17446], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "q", "text": ["project non-divergent"]}, " step of the simulation removes the divergence components in the velocity field."], "extent": [17446, 17556]}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Projection Method"], "extent": [17556, 17575], "body": [{"type": "para", "indent": 4, "text": ["The project non-divergence algorithm. ", {"type": "q", "text": ["PCG"]}, " has more accurate boundary conditions and avoids computation inside collision objects. Multigrid is significantly faster, especially on large or high resolution containers."], "extent": [17575, 17797]}, {"type": "note_group", "body": [{"type": "note", "indent": 4, "role": "item", "extent": [17797, 17807], "body": [{"type": "para", "indent": 8, "text": ["PCG is only used for face-sampled velocity fields.  If set to center-sampled, a different relaxation method is used.  For center-sampled, multigrid should always be used."], "extent": [17807, 17987]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Multigrid Iterations"], "extent": [17987, 18009], "body": [{"type": "para", "indent": 4, "text": ["The multigrid project non-divergence method has inaccurate boundary enforcement. You can increase this number to run the enforcement/projection multiple times, making it more accurate. You should not have to set this higher than ", {"type": "code", "text": ["5"]}, "."], "extent": [18009, 18248]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "adv_advectiontab", "container": true, "type": "h", "indent": 0, "text": ["Advection"], "extent": [18248, 18285], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Advection Type"], "extent": [18285, 18302], "body": [{"type": "para", "indent": 4, "text": ["The algorithm to use for advecting the fields."], "extent": [18302, 18358]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Single stage"], "extent": [18358, 18376], "body": [{"type": "para", "indent": 8, "text": ["Equivalent to the ", {"scheme": "Node", "value": "/nodes/dop/gasadvect", "type": "link", "text": ["Gas Advect DOP"], "fullpath": "/nodes/dop/gasadvect.html"}, ", where each point is back traced through the velocity field once to find the new voxel value."], "extent": [18376, 18533]}], "container": true}, {"type": "dt", "indent": 4, "text": ["BFECC and Modified MacCormack"], "extent": [18533, 18568], "body": [{"type": "para", "indent": 8, "text": ["Run a second basic advection stage, resulting in a sharper fluid that doesn\u2019t disperse as much."], "extent": [18568, 18673]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Clamp Values"], "extent": [18673, 18687], "body": [{"type": "para", "indent": 4, "text": ["The error correction of the BFECC and Modified MacCormack advection types can move voxel values outside the container, leading to strange effects such as negative density values. This parameter lets you choose a method to avoid this problem. The default is ", {"type": "q", "text": ["Revert"]}, "."], "extent": [18687, 18963]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["None"], "extent": [18963, 18973], "body": [{"type": "para", "indent": 8, "text": ["Do not attempt to prevent error correction from moving values outside the container."], "extent": [18973, 19075]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Clamp"], "extent": [19075, 19086], "body": [{"type": "para", "indent": 8, "text": ["Restrict each voxel to the range of values possible given its eight original values."], "extent": [19086, 19180]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Revert"], "extent": [19180, 19192], "body": [{"type": "para", "indent": 8, "text": ["If the error-corrected voxel is out of range, return it to the single-stage value."], "extent": [19192, 19292]}], "container": true}], "container": true}, {"type": "para", "indent": 4, "text": ["Reverting can avoid checker artifacts where the error correction breaks down."], "extent": [19292, 19375]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Blend"], "extent": [19375, 19382], "body": [{"type": "para", "indent": 4, "text": ["Apply a smooth blend between non-clamped and clamped values as the advected field\n    approaches the clamping limit. Particularly with the ", {"type": "ui", "text": ["Revert"]}, " option, applying a small\n    amount of ", {"type": "ui", "text": ["Blend"]}, " (e.g. 0.05 - 0.1) can reduce grid artifacts in the advected field\n    at the cost of some additional smoothing of the field."], "extent": [19382, 19711]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Vel Advection Type"], "extent": [19711, 19731], "body": [{"type": "para", "indent": 4, "text": ["The algorithm to use for advecting the velocity field. Higher types in the list will reduce the apparent viscosity of the field, but may add energy or cause chatter."], "extent": [19731, 19902]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Advection Method"], "extent": [19902, 19920], "body": [{"type": "para", "indent": 4, "text": ["Controls particle tracing."], "extent": [19920, 19956]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Single step"], "extent": [19956, 19973], "body": [{"type": "para", "indent": 8, "text": ["Takes the velocity at each voxel and makes a single step in\n        that direction for the time step. This is fastest and is\n        independent of the speed of the velocity field, but will start\n        to break up for large time steps."], "extent": [19973, 20228]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Trace"], "extent": [20228, 20239], "body": [{"type": "para", "indent": 8, "text": ["Ensures the backtracking does not move more than a single\n        voxel before its velocity is updated, allowing for larger\n        time steps."], "extent": [20239, 20400]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Trace Midpoint"], "extent": [20400, 20420], "body": [{"type": "para", "indent": 8, "text": ["Like ", {"type": "ui", "text": ["Trace"]}, " but uses second order advection for more accuracy\n        but slower simulation."], "extent": [20420, 20533]}], "container": true}, {"type": "dt", "indent": 4, "text": ["HJWENO"], "extent": [20533, 20545], "body": [{"type": "para", "indent": 8, "text": ["A non-lagrangian integrator, this allows for theoretically more\n        accurate advection of divergent fields.  Unfortunately, if too large\n        substeps are taken, it will explode."], "extent": [20545, 20748]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Upwind"], "extent": [20748, 20760], "body": [{"type": "para", "indent": 8, "text": ["A faster but less accurate non-lagrangian integrator."], "extent": [20760, 20823]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Trace RK3"], "extent": [20823, 20838], "body": [{"type": "para", "indent": 8, "text": ["Like ", {"type": "ui", "text": ["Trace"]}, " but uses third order advection for more accuracy\n        but slower simulation."], "extent": [20838, 20942]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Trace RK4"], "extent": [20942, 20957], "body": [{"type": "para", "indent": 8, "text": ["Like ", {"type": "ui", "text": ["Trace"]}, " but uses fourth order advection for more accuracy\n        but slower simulation."], "extent": [20957, 21062]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Advection CFL"], "extent": [21062, 21077], "body": [{"type": "para", "indent": 4, "text": ["When tracing the particles, this controls how many voxels the particles can move in a single iterations. Higher values give faster tracing and faster advection, but more errors."], "extent": [21077, 21260]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "adv_collisionstab", "container": true, "type": "h", "indent": 0, "text": ["Collisions"], "extent": [21260, 21299], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Correct Collisions"], "extent": [21299, 21320], "body": [{"type": "para", "indent": 4, "text": ["Sets the specified fields to ", {"type": "code", "text": ["0"]}, " inside collision objects, which helps prevent leaking through moving objects."], "extent": [21320, 21436]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Fields to Correct"], "extent": [21436, 21455], "body": [{"type": "para", "indent": 4, "text": ["When ", {"type": "ui", "text": ["Correct Collisions"]}, " is turned on, fields in this list will have a correction applied inside collision objects."], "extent": [21455, 21579]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Feedback Scale"], "extent": [21579, 21595], "body": [{"type": "para", "indent": 4, "text": ["A scale factor for applying feedback forces to other objects. Setting this to ", {"type": "code", "text": ["0"]}, " will prevent any feedback."], "extent": [21595, 21713]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "adv_cleartab", "container": true, "type": "h", "indent": 0, "text": ["Clear"], "extent": [21713, 21742], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Fields to Clear"], "extent": [21742, 21760], "body": [{"type": "para", "indent": 8, "text": ["Zeros out the specified types of fields after the solve step. This ensures the ", {"type": "code", "text": [".sim"]}, " files, which store the complete state of the simulation, do not have extra information, reducing their size and saving time."], "extent": [21760, 21988]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["None"], "extent": [21988, 21998], "body": [{"type": "para", "indent": 12, "text": ["Do not clear fields."], "extent": [21998, 22036]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Hidden"], "extent": [22036, 22048], "body": [{"type": "para", "indent": 8, "text": ["Clear fields not needed for the next time step that do not have guide parameters."], "extent": [22048, 22143]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Static"], "extent": [22143, 22155], "body": [{"type": "para", "indent": 8, "text": ["Clear fields not needed for next time step. Some of these fields will have guides and the guides will start showing zero values since the underlying field was cleared."], "extent": [22155, 22336]}], "container": true}], "container": true}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Additional"], "extent": [22336, 22348], "body": [{"type": "para", "indent": 8, "text": ["A space separated list of fields to clear after each solve."], "extent": [22348, 22417]}], "container": true, "role": "item"}], "container": true, "role": "item_group"}]}]}], "text": "Parameters"}, {"level": 1, "id": "outputs", "container": true, "type": "outputs_section", "indent": 0, "role": "section", "extent": [22417, 22426], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["First Output"], "extent": [15, 29], "body": [{"type": "para", "indent": 4, "text": ["The operation of this output depends on what inputs are connected\n    to this node. If an object stream is input to this node, the output\n    is also an object stream containing the same objects as the input\n    (but with the data from this node attached). "], "extent": [29, 296]}, {"type": "para", "indent": 4, "text": ["If no object stream is\n    connected to this node, the output is a data output. This data\n    output can be connected to an ", {"scheme": "Node", "value": "/nodes/dop/applydata", "type": "link", "text": ["Apply Data DOP"], "fullpath": "/nodes/dop/applydata.html"}, ",\n    or connected directly to a data input of another data node, to\n    attach the data from this node to an object or another piece of\n    data."], "extent": [296, 606]}], "container": true}], "container": true}], "text": "Outputs"}, {"level": 1, "id": "locals", "container": true, "type": "locals_section", "indent": 0, "role": "section", "extent": [22460, 22468], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 0, "text": ["channelname"], "extent": [16, 29], "body": [{"type": "para", "indent": 4, "text": ["This DOP node defines a local variable for each channel and\n    parameter on the Data Options page, with the same name as the\n    channel. So for example, the node may have channels for Position\n    (positionx, positiony, positionz) and a parameter for an object name\n    (objectname). "], "extent": [29, 325]}, {"type": "para", "indent": 4, "text": ["Then there will also be local variables with the names\n    positionx, positiony, positionz, and objectname. These variables\n    will evaluate to the previous value for that parameter. "], "extent": [325, 519]}, {"type": "para", "indent": 4, "text": ["This previous value is always stored as part of the data attached to the\n    object being processed. This is essentially a shortcut for a\n    dopfield expression like:"], "extent": [519, 692]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    dopfield($DOPNET, $OBJID, dataName, \"Options\", 0, channelname)\n    "], "extent": [692, 775]}, {"type": "para", "indent": 4, "text": ["If the data does not already exist, then a value of zero or an\n    empty string will be returned."], "extent": [775, 883]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DATACT"], "extent": [883, 891], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation time (see variable ST) at which the\n    current data was created. This value may not be the same as the\n    current simulation time if this node is modifying existing data,\n    rather than creating new data."], "extent": [891, 1132]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DATACF"], "extent": [1132, 1140], "body": [{"type": "para", "indent": 4, "text": ["This value is the simulation frame (see variable SF) at which the\n    current data was created. This value may not be the same as the\n    current simulation frame if this node is modifying existing data,\n    rather than creating new data."], "extent": [1140, 1383]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELNAME"], "extent": [1383, 1392], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [1392, 1594]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to the\n    name of the relationship to which the data is being attached."], "extent": [1594, 1703]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELOBJIDS"], "extent": [1703, 1714], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [1714, 1916]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the object identifiers for all\n    the Affected Objects of the relationship to which the data is being\n    attached."], "extent": [1916, 2119]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELOBJNAMES"], "extent": [2119, 2132], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [2132, 2334]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the names of all the Affected\n    Objects of the relationship to which the data is being attached."], "extent": [2334, 2519]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELAFFOBJIDS"], "extent": [2519, 2533], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [2533, 2735]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the object identifiers for all\n    the Affector Objects of the relationship to which the data is being\n    attached."], "extent": [2735, 2938]}], "container": true}, {"type": "dt", "indent": 0, "text": ["RELAFFOBJNAMES"], "extent": [2938, 2954], "body": [{"type": "para", "indent": 4, "text": ["This value will be set only when data is being attached to a relationship\n    (such as when Constraint Anchor DOP is connected to the second, third, of\n    fourth inputs of a Constraint DOP). "], "extent": [2954, 3156]}, {"type": "para", "indent": 4, "text": ["In this case, this value is set to a\n    string that is a space separated list of the names of all the Affector\n    Objects of the relationship to which the data is being attached."], "extent": [3156, 3341]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ST"], "extent": [16, 20], "body": [{"type": "para", "indent": 4, "text": ["The simulation time for which the node is being evaluated. "], "extent": [20, 89]}, {"type": "para", "indent": 4, "text": ["Depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP Network"], "fullpath": "/nodes/obj/dopnet.html"}, " \n    ", {"type": "ui", "text": ["Offset Time"]}, " and ", {"type": "ui", "text": ["Scale Time"]}, " parameters, \n    this value may not be equal to the current Houdini time\n    represented by the variable T. "], "extent": [89, 310]}, {"type": "para", "indent": 4, "text": ["ST is guaranteed to have a value of zero at the\n    start of a simulation, so when testing for the first timestep of a\n    simulation, it is best to use a test like ", {"type": "code", "text": ["$ST == 0"]}, ", rather than\n    ", {"type": "code", "text": ["$T == 0"]}, " or ", {"type": "code", "text": ["$FF == 1"]}, "."], "extent": [310, 533]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SF"], "extent": [533, 537], "body": [{"type": "para", "indent": 4, "text": ["The simulation frame (or more accurately, the \n    simulation time step number) for which the node is being evaluated."], "extent": [537, 665]}, {"type": "para", "indent": 4, "text": ["Depending on the settings of the ", {"scheme": "Node", "value": "/nodes/obj/dopnet", "type": "link", "text": ["DOP Network"], "fullpath": "/nodes/obj/dopnet.html"}, " parameters, \n    this value may not be equal to the current Houdini frame number\n    represented by the variable F. Instead, it is equal to\n    the simulation time (ST) divided by the simulation timestep size \n    (TIMESTEP)."], "extent": [665, 959]}], "container": true}, {"type": "dt", "indent": 0, "text": ["TIMESTEP"], "extent": [959, 969], "body": [{"type": "para", "indent": 4, "text": ["The size of a simulation timestep. This value is\n    useful for scaling values that are expressed in units per second, but\n    are applied on each timestep."], "extent": [969, 1131]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SFPS"], "extent": [1131, 1137], "body": [{"type": "para", "indent": 4, "text": ["The inverse of the TIMESTEP value. It is the number\n    of timesteps per second of simulation time."], "extent": [1137, 1242]}], "container": true}, {"type": "dt", "indent": 0, "text": ["SNOBJ"], "extent": [1242, 1249], "body": [{"type": "para", "indent": 4, "text": ["The number of objects in the simulation. For nodes that\n    create objects such as the ", {"scheme": "Node", "value": "/nodes/dop/emptyobject", "type": "link", "text": ["Empty Object DOP"], "fullpath": "/nodes/dop/emptyobject.html"}, ",\n    SNOBJ increases for each object that is evaluated. "], "extent": [1249, 1442]}, {"type": "para", "indent": 4, "text": ["A good way to guarantee unique object names is to use an expression\n    like ", {"type": "code", "text": ["object_$SNOBJ"]}, "."], "extent": [1442, 1541]}], "container": true}, {"type": "dt", "indent": 0, "text": ["NOBJ"], "extent": [1541, 1547], "body": [{"type": "para", "indent": 4, "text": ["The number of objects that are evaluated by the\n    current node during this timestep. This value is often \n    different from SNOBJ, as many nodes do not process all the objects\n    in a simulation. "], "extent": [1547, 1757]}, {"type": "para", "indent": 4, "text": ["NOBJ may return 0 if the node does not\n    process each object sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group\n    DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [1757, 1884]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJ"], "extent": [1884, 1889], "body": [{"type": "para", "indent": 4, "text": ["The index of the specific object being processed by\n    the node. This value always runs from zero to NOBJ-1 in a given\n    timestep. It does not identify the current object within the\n    simulation like OBJID or OBJNAME; it only identifies the object\u2019s \n    position in the current order of processing. "], "extent": [1889, 2204]}, {"type": "para", "indent": 4, "text": ["This value is useful for generating a\n    random number for each object, or simply splitting the objects into\n    two or more groups to be processed in different ways. This value\n    is -1 if the node does not process objects sequentially (such\n    as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [2204, 2494]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJID"], "extent": [2494, 2501], "body": [{"type": "para", "indent": 4, "text": ["The unique identifier for the object being\n    processed. Every object is assigned an integer value that is unique\n    among all objects in the simulation for all time. Even if an object\n    is deleted, its identifier is never reused. This is very useful in\n    situations where each object needs to be treated differently, for \n    example, to produce a unique random number for each object. "], "extent": [2501, 2900]}, {"type": "para", "indent": 4, "text": ["This value is also the best way to look up information on an object using the dopfield expression function. "], "extent": [2900, 3014]}, {"type": "para", "indent": 4, "text": ["OBJID is -1 if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3014, 3127]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJIDS"], "extent": [3127, 3138], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space-separated list of the unique object\n    identifiers for every object being processed by the current node."], "extent": [3138, 3278]}], "container": true}, {"type": "dt", "indent": 0, "text": ["ALLOBJNAMES"], "extent": [3278, 3291], "body": [{"type": "para", "indent": 4, "text": ["This string contains a space-separated list of the names of every\n    object being processed by the current node."], "extent": [3291, 3410]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCT"], "extent": [3410, 3417], "body": [{"type": "para", "indent": 4, "text": ["The simulation time (see variable ST) at which the\n    current object was created. "], "extent": [3417, 3510]}, {"type": "para", "indent": 4, "text": ["To check if an object was created\n    on the current timestep, the expression ", {"type": "code", "text": ["$ST == $OBJCT"]}, " should\n    always be used. "], "extent": [3510, 3637]}, {"type": "para", "indent": 4, "text": ["This value is zero if the node does not process\n    objects sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3637, 3757]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJCF"], "extent": [3757, 3764], "body": [{"type": "para", "indent": 4, "text": ["The simulation frame (see variable SF) at which the \n    current object was created. It is equivalent to using the \n    dopsttoframe expression on the OBJCT variable. "], "extent": [3764, 3937]}, {"type": "para", "indent": 4, "text": ["This value is zero if the node does not process objects \n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [3937, 4058]}], "container": true}, {"type": "dt", "indent": 0, "text": ["OBJNAME"], "extent": [4058, 4067], "body": [{"type": "para", "indent": 4, "text": ["A string value containing the name of the object being\n    processed. "], "extent": [4067, 4147]}, {"type": "para", "indent": 4, "text": ["Object names are not guaranteed to be unique within a\n    simulation. However, if you name your objects carefully so that they\n    are unique, the object name can be a much easier way to identify an\n    object than the unique object identifier, OBJID. "], "extent": [4147, 4409]}, {"type": "para", "indent": 4, "text": ["The object name can\n    also be used to treat a number of similar objects (with the same\n    name) as a virtual group. If there are 20 objects named ", {"type": "q", "text": ["myobject"]}, ",\n    specifying ", {"type": "code", "text": ["strcmp($OBJNAME, \"myobject\") == 0"]}, " in the activation field\n    of a DOP will cause that DOP to operate on only those 20 objects. "], "extent": [4409, 4721]}, {"type": "para", "indent": 4, "text": ["This value is the empty string if the node does not process objects\n    sequentially (such as the ", {"scheme": "Node", "value": "/nodes/dop/group", "type": "link", "text": ["Group DOP"], "fullpath": "/nodes/dop/group.html"}, ")."], "extent": [4721, 4853]}], "container": true}, {"type": "dt", "indent": 0, "text": ["DOPNET"], "extent": [4853, 4861], "body": [{"type": "para", "indent": 4, "text": ["A string value containing the full path of the current DOP\n    network. This value is most useful in DOP subnet digital assets\n    where you want to know the path to the DOP network that contains the\n    node."], "extent": [4861, 5076]}], "container": true}], "container": true}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [5076, 5082], "body": [{"type": "para", "indent": 4, "text": ["Most dynamics nodes have local variables with the same names as the\n    node\u2019s parameters. For example, in a ", {"scheme": "Node", "value": "/nodes/dop/position", "type": "link", "text": ["Position DOP"], "fullpath": "/nodes/dop/position.html"}, ",\n    you could write the expression:"], "extent": [5082, 5270]}, {"lang": null, "type": "pre", "indent": 4, "text": ["\n    $tx + 0.1\n    "], "extent": [5270, 5300]}, {"type": "para", "indent": 4, "text": ["\u2026to make the object move 0.1 units along the X axis at each timestep."], "extent": [5300, 5380]}], "container": true}], "container": true, "role": "item_group"}], "text": "Locals"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [22528, 22537], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/pyro/pyro", "type": "link", "text": ["Pyro Effects"], "fullpath": "/pyro/pyro.html"}], "extent": [22537, 22566]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/smokeobject", "type": "link", "text": "", "fullpath": "/nodes/dop/smokeobject.html"}], "extent": [22566, 22591]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/pyrosource", "type": "link", "text": "", "fullpath": "/nodes/sop/pyrosource.html"}], "extent": [22591, 22615]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/dop/pyrosolver", "type": "link", "text": "", "fullpath": "/nodes/dop/pyrosolver.html"}], "extent": [22615, 22640]}], "container": true}], "text": "Related"}], "title": ["Smoke Solver"], "summary": ["Sets and configures a Smoke solver. This is a slightly lower-level solver that is the basis for the Pyro solver."], "included": ["/nodes/dop/gassubstep", "/nodes/dop/old_relationships", "/nodes/dop/standard_data_locals", "/nodes/dop/standard_data_outputs", "/nodes/dop/standard_datagroup_parms", "/nodes/dop/standard_dataname_parms", "/nodes/dop/standard_dataop_parms", "/nodes/dop/standard_distribution", "/nodes/dop/standard_locals", "/nodes/dop/standard_microsolver_inputs", "/nodes/dop/standard_solver_mutualparms", "/nodes/dop/standard_solver_parms"]}